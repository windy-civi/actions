name: "OpenStates Formatter"
description: "Format scraped legislative data to blockchain layout and push to caller repo"

inputs:
  state:
    description: "State abbreviation (e.g., id, il, tx, ny, or 'usa')"
    required: true
  github-token:
    description: "GitHub token for releases/artifacts"
    required: true
    default: "${{ github.token }}"
  scrape-artifact-name:
    description: "Name of the scrape artifact to download"
    required: false
    default: "scrape-snapshot-nightly"
  force-update:
    description: "Force push even if upstream changed"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.13"

    - name: Download scrape artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.scrape-artifact-name }}
        path: ${{ github.workspace }}

    - name: Extract tarball for formatter
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p "${RUNNER_TEMP}/scrape-snapshot-nightly"
        tar xzf "${GITHUB_WORKSPACE}/scrape-snapshot-nightly.tgz" -C "${RUNNER_TEMP}/scrape-snapshot-nightly"
        echo "✅ Extraction complete"

    - name: Ensure jq present
      shell: bash
      run: |
        set -euo pipefail
        command -v jq >/dev/null 2>&1 || sudo apt-get update && sudo apt-get install -y jq

    - name: Sanitize scraped JSON (_id, scraped_at)
      shell: bash
      working-directory: ${{ runner.temp }}/scrape-snapshot-nightly
      run: |
        set -euo pipefail
        tmpc="${RUNNER_TEMP}/san_count.txt"
        : > "$tmpc"
        find . -type f -name "*.json" -print0 | while IFS= read -r -d '' f; do
          jq 'del(..|._id?, .scraped_at?)' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
          echo 1 >> "$tmpc"
        done
        echo "Sanitized $(wc -l < "$tmpc") files"

    - name: Install formatter deps (pipenv)
      shell: bash
      working-directory: ${{ github.action_path }}/../..
      env:
        PIPENV_VENV_IN_PROJECT: "1"
        PIPENV_IGNORE_VIRTUALENVS: "1"
      run: |
        set -euo pipefail
        python -m pip install --upgrade pip
        pip install pipenv
        pipenv install --deploy --dev

    - name: Run formatter
      shell: bash
      env:
        OPENSTATE_DATA_FOLDER: ${{ runner.temp }}/scrape-snapshot-nightly
        GIT_REPO_FOLDER: ${{ github.workspace }}
        STATE: ${{ inputs.state }}
      run: |
        set -euo pipefail
        cd "${{ github.action_path }}/../.."
        pipenv run python scrape_and_format/main.py \
          --state "$STATE" \
          --openstates-data-folder "$OPENSTATE_DATA_FOLDER" \
          --git-repo-folder "$GIT_REPO_FOLDER"

    - name: Clean ephemeral build dirs
      shell: bash
      run: |
        set -euo pipefail
        rm -rf bill_session_mapping sessions || true

    - name: Commit & push to caller repo
      shell: bash
      run: |
        set -euo pipefail
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"

        # Only commit the actual deliverables
        git add data_output/ || true
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          # Pull latest changes before committing to avoid conflicts with concurrent jobs
          echo "📥 Pulling latest changes..."
          git pull --rebase origin main || {
            echo "⚠️ Rebase conflict detected, attempting to resolve..."
            # Our changes are in data_output/, so accept ours for that directory
            git checkout --ours data_output/
            git add data_output/
            git rebase --continue || true
          }

          git commit -m "Automated OpenStates data update for ${{ inputs.state }}"
          
          # Retry push up to 3 times in case of concurrent updates
          for i in 1 2 3; do
            if [ "${{ inputs.force-update }}" = "true" ]; then
              if git push --force-with-lease origin main; then
                echo "✅ Changes pushed successfully (attempt $i)"
                break
              fi
            else
              if git push origin main; then
                echo "✅ Changes pushed successfully (attempt $i)"
                break
              fi
            fi
            
            if [ $i -lt 3 ]; then
              echo "⚠️ Push failed (attempt $i), pulling and retrying..."
              git pull --rebase origin main
              sleep 2
            else
              echo "❌ Failed to push after 3 attempts"
              exit 1
            fi
          done
        fi
