# üìã Project Rules & Guidelines

## üéØ **Project Overview**

This repository is a local sandbox for extracting and processing federal bill data from OpenStates for downstream AI analysis. It follows blockchain-style, versioned data structures and is part of the Windy Civi ecosystem.

**Primary Use Case**: This codebase is designed to be deployed as a GitHub Actions workflow across multiple repositories - one for each jurisdiction supported by OpenStates scrapers. Each repository runs automated nightly processing of legislative data.

**Jurisdictions Covered**: 56 total jurisdictions including:

- **50 US States**: al, ak, az, ar, ca, co, ct, de, fl, ga, hi, id, il, in, ia, ks, ky, la, me, md, ma, mi, mn, ms, mo, mt, ne, nv, nh, nj, nm, ny, nc, nd, oh, ok, or, pa, ri, sc, sd, tn, tx, ut, vt, va, wa, wv, wi, wy
- **Federal Government**: usa
- **Territories & Districts**: dc (District of Columbia), gu (Guam), mp (Northern Mariana Islands), pr (Puerto Rico), vi (US Virgin Islands)

---

## üèóÔ∏è **Development Standards**

### **Code Organization**

- **Handlers** (`openstates_scraped_data_formatter/handlers/`): One handler per data type (bills, events, vote_events)
- **Utils** (`openstates_scraped_data_formatter/utils/`): Shared utilities for file operations, timestamps, etc.
- **Postprocessors** (`openstates_scraped_data_formatter/postprocessors/`): Data linking and relationship processing
- **Scripts** (`scripts/`): Standalone utilities and testing scripts

### **Naming Conventions**

- **Files**: Use snake_case for Python files (`bill_handler.py`, `file_utils.py`)
- **Functions**: Use snake_case with descriptive names (`handle_bill()`, `format_timestamp()`)
- **Variables**: Use UPPER_CASE for constants, snake_case for variables
- **Classes**: Use PascalCase (`LatestTimestamps`, `SessionInfo`)

### **Code Style**

- Follow PEP 8 standards
- Use type hints for all function parameters and return values
- Include docstrings for all functions and classes
- Keep functions focused on single responsibilities
- Use meaningful variable names (avoid abbreviations)

---

## üìä **Data Handling Rules**

### **Input Data Standards**

- **Source**: Only process data from official OpenStates scrapers
- **Format**: JSON files with OpenStates schema compliance
- **Validation**: All input files must have required fields (`identifier`, `legislative_session`)
- **Sanitization**: Remove `_id` and `scraped_at` fields for deterministic output

### **Output Data Structure**

```
data_output/
‚îú‚îÄ‚îÄ data_processed/
‚îÇ   ‚îî‚îÄ‚îÄ country:us/
‚îÇ       ‚îú‚îÄ‚îÄ congress/ (federal) or state:{abbr}/ (state)
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ sessions/
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ {session_id}/
‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ bills/
‚îÇ       ‚îÇ               ‚îî‚îÄ‚îÄ {bill_id}/
‚îÇ       ‚îÇ                   ‚îú‚îÄ‚îÄ logs/ (timestamped JSONs)
‚îÇ       ‚îÇ                   ‚îî‚îÄ‚îÄ files/ (source documents)
‚îú‚îÄ‚îÄ data_not_processed/ (error logs)
‚îî‚îÄ‚îÄ event_archive/ (temporary event storage)
```

### **Data Integrity Rules**

- **Immutable Logs**: Once written, log files should never be modified
- **Timestamp Tracking**: Maintain `latest_timestamps.json` for incremental processing
- **Session Mapping**: Ensure all bills are properly mapped to legislative sessions
- **Error Handling**: Log all processing failures with detailed error information

---

## üîí **Security & Privacy**

### **Data Security**

- **No PII**: Never store personally identifiable information in processed data
- **Source Attribution**: Always maintain source URLs and citations
- **Access Control**: Use appropriate file permissions for sensitive data
- **Audit Trail**: Maintain complete processing logs for data lineage

### **API Usage**

- **Rate Limiting**: Respect OpenStates API rate limits
- **Authentication**: Use proper authentication for any API calls
- **Error Handling**: Gracefully handle API failures and timeouts
- **Caching**: Cache session mappings to reduce API calls

---

## üîÑ **Workflow Guidelines**

### **Local Development**

1. **Setup**: Always use virtual environment (`venv/`)
2. **Testing**: Test with sample data before processing full datasets
3. **Incremental Processing**: Use timestamp tracking to avoid reprocessing
4. **Validation**: Verify output structure matches expected format

### **GitHub Actions Integration**

- **Multi-Repository Deployment**: This codebase is deployed across 56 repositories (50 states + federal + 5 territories)
- **Jurisdiction Configuration**: Use jurisdiction abbreviations (e.g., `il`, `tx`, `wi` for states, `usa` for federal, `dc`, `gu`, `mp`, `pr`, `vi` for territories)
- **Repository Naming**: Follow convention `{JURISDICTION}-data-pipeline` (e.g., `il-data-pipeline`, `usa-data-pipeline`, `dc-data-pipeline`)
- **Data Storage**: Disable `_data/` folder in production to keep repo lightweight
- **Scheduling**: Use cron expressions for automated runs (default: 1am UTC)
- **Manual Triggers**: Allow manual workflow execution for testing
- **Jurisdiction-Specific Configuration**: Each repository must have its own jurisdiction abbreviation in workflow files

### **Error Handling**

- **Graceful Degradation**: Continue processing even if individual files fail
- **Detailed Logging**: Log all errors with context and file information
- **Recovery**: Provide mechanisms to retry failed processing
- **Notification**: Alert on critical processing failures

### **Multi-Repository Deployment Rules**

- **Template Repository**: This repo serves as the template for all 56 jurisdiction repositories
- **Jurisdiction Isolation**: Each repository processes only its designated jurisdiction's data
- **Configuration Files**: Each deployment must have jurisdiction-specific configuration in workflow files
- **Data Separation**: Ensure no cross-jurisdiction data contamination in processing
- **Consistent Structure**: All repositories must maintain identical folder structures
- **Version Synchronization**: Keep all repositories on the same code version for consistency
- **Deployment Checklist**: Verify jurisdiction abbreviation, API endpoints, and data sources before deployment
- **Jurisdiction-Specific Handling**: Account for different data formats between states, federal, and territories

---

## üìù **Documentation Standards**

### **Code Documentation**

- **Function Docstrings**: Include purpose, parameters, return values, and examples
- **Inline Comments**: Explain complex logic and business rules
- **README Updates**: Keep setup instructions current
- **API Documentation**: Document any new endpoints or data structures

### **Data Documentation**

- **Schema Documentation**: Document all data structures and field meanings
- **Processing Logs**: Maintain clear logs of data transformations
- **Version History**: Track changes to data processing logic
- **Sample Data**: Provide representative examples of input/output data

---

## üß™ **Testing & Quality Assurance**

### **Testing Requirements**

- **Unit Tests**: Test individual functions and handlers
- **Integration Tests**: Test complete processing pipelines
- **Data Validation**: Verify output data meets schema requirements
- **Performance Testing**: Monitor processing time and resource usage

### **Quality Checks**

- **Data Completeness**: Ensure all required fields are present
- **Data Consistency**: Verify relationships between related data
- **Format Compliance**: Validate JSON structure and encoding
- **Cross-Reference Validation**: Check bill-event-vote relationships

---

## üöÄ **Deployment & Operations**

### **Environment Management**

- **Dependencies**: Pin all package versions in `requirements.txt`
- **Configuration**: Use environment variables for configurable settings
- **Secrets**: Store API keys and credentials securely
- **Monitoring**: Track processing metrics and error rates

### **Performance Guidelines**

- **Memory Usage**: Process large datasets in chunks
- **File I/O**: Minimize disk operations and use efficient file formats
- **Parallel Processing**: Use multiprocessing where appropriate
- **Resource Limits**: Set appropriate timeouts and memory limits

### **Automated Processing Rules**

- **Nightly Execution**: All 56 repositories run automated processing at 1am UTC
- **Resource Management**: Optimize for GitHub Actions runner limitations (time, memory, storage)
- **Incremental Processing**: Use timestamp tracking to avoid reprocessing unchanged data
- **Failure Recovery**: Implement retry logic for transient failures (network, API timeouts)
- **Processing Windows**: Respect OpenStates API rate limits across all repositories
- **Monitoring**: Track processing success/failure rates across all repositories
- **Alerting**: Set up notifications for processing failures or data quality issues
- **Jurisdiction-Specific Scheduling**: Consider staggered processing times to avoid API rate limit conflicts

### **Jurisdiction-Specific Considerations**

- **Data Format Variations**: Different jurisdictions may have different data structures and field names
- **Session Naming**: Federal Congress uses numbered sessions (e.g., "119"), states may use different conventions
- **Bill Identifiers**: Federal bills use format like "HR 1493", state bills may use different numbering systems
- **Territory Handling**: Territories (dc, gu, mp, pr, vi) may have different legislative structures than states
- **Federal vs State**: Federal government data structure differs significantly from state legislatures
- **Data Availability**: Some jurisdictions may have limited or different types of legislative data
- **API Endpoints**: Different jurisdictions may use different OpenStates API endpoints or data sources

### **Versioning & State-Specific Customizations**

- **Base Version**: Maintain a core version that works for the majority of jurisdictions
- **State-Specific Branches**: Create jurisdiction-specific branches for customizations (e.g., `feature/california-custom`, `feature/texas-special-handling`)
- **Configuration-Driven**: Use configuration files to handle most jurisdiction differences without code changes
- **Handler Extensions**: Create jurisdiction-specific handlers when data formats differ significantly
- **Version Tagging**: Tag releases with jurisdiction-specific versions (e.g., `v1.2.0-california`, `v1.2.0-texas`)
- **Custom Processing Logic**: Allow jurisdiction-specific processing steps through configuration
- **Backward Compatibility**: Ensure customizations don't break processing for other jurisdictions
- **Documentation**: Maintain clear documentation of jurisdiction-specific customizations and their purposes

## ü§ù **Collaboration Rules**

### **Version Control**

- **Branch Strategy**: Use feature branches for development
- **Commit Messages**: Use descriptive commit messages with issue references
- **Pull Requests**: Require code review for all changes
- **Merge Strategy**: Use squash and merge for clean history

### **Issue Management**

- **Bug Reports**: Include reproduction steps and error logs
- **Feature Requests**: Provide clear use cases and requirements
- **Documentation**: Update docs with any new features or changes
- **Communication**: Use GitHub issues for all project discussions

---

## üìã **Compliance & Legal**

### **Data Usage**

- **OpenStates License**: Comply with OpenStates data usage terms
- **Attribution**: Maintain proper attribution for all data sources
- **Usage Rights**: Respect copyright and usage restrictions
- **Data Retention**: Follow appropriate data retention policies

### **Regulatory Compliance**

- **FOIA Compliance**: Ensure data processing meets public records requirements
- **Privacy Laws**: Comply with relevant privacy regulations
- **Audit Requirements**: Maintain records for compliance audits
- **Data Governance**: Follow established data governance policies

---

## üîß **Maintenance & Updates**

### **Regular Maintenance**

- **Dependency Updates**: Regularly update dependencies for security
- **Code Reviews**: Conduct periodic code reviews and refactoring
- **Performance Monitoring**: Track and optimize processing performance
- **Documentation Updates**: Keep documentation current with code changes

### **Version Management**

- **Semantic Versioning**: Use semantic versioning for releases
- **Changelog**: Maintain detailed changelog of all changes
- **Backward Compatibility**: Maintain compatibility when possible
- **Migration Paths**: Provide clear migration instructions for breaking changes

### **State-Specific Version Management**

- **Core Repository**: Maintain the main repository as the source of truth for common functionality
- **Fork Strategy**: Use repository forks for state-specific customizations when needed
- **Custom Handler Registry**: Maintain a registry of jurisdiction-specific handlers and their purposes
- **Configuration Inheritance**: Use base configuration with jurisdiction-specific overrides
- **Testing Strategy**: Test customizations against the specific jurisdiction's data format
- **Merge Strategy**: Periodically merge improvements from the core repository to custom versions
- **Version Compatibility Matrix**: Document which versions work with which jurisdictions
- **Rollback Procedures**: Have clear procedures for rolling back jurisdiction-specific changes

### **Implementation Strategies for State-Specific Needs**

- **Configuration Files**: Use JSON/YAML config files to handle jurisdiction differences
- **Handler Factory Pattern**: Create handlers dynamically based on jurisdiction configuration
- **Plugin Architecture**: Allow jurisdiction-specific plugins for custom processing logic
- **Data Validation**: Implement jurisdiction-specific validation rules
- **Error Handling**: Customize error handling for jurisdiction-specific data issues
- **Output Formatting**: Allow jurisdiction-specific output formats when needed
- **Dependency Management**: Manage jurisdiction-specific dependencies separately
- **Deployment Automation**: Automate deployment of custom versions to specific jurisdictions

## üìû **Support & Escalation**

### **Support Channels**

- **GitHub Issues**: Primary support channel for bugs and features
- **Documentation**: Self-service support through comprehensive docs
- **Community**: Engage with Windy Civi community for help
- **Escalation**: Clear escalation path for critical issues

### **Response Times**

- **Critical Issues**: Respond within 24 hours
- **Feature Requests**: Acknowledge within 1 week
- **Documentation**: Update within 1 week of code changes
- **Security Issues**: Immediate response and fix

---

_Last Updated: [Current Date]_
_Version: 1.0_

---

description:
globs:
alwaysApply: false

---
